Pranav Subramaniam, psubramaniam.uchicago.edu
Project 3

My submission folder consists of the file "mproxy.py" and the directory "log",
which has samples of HTTP request/response pairs from the client (the Firefox browser
on my computer) to various servers. To run my application, simply use the command:

"python mproxy.py [cmd-options]"

where "cmd-options" is any combination of the command line arguments specified in the lab writeup.
This program is an HTTP/HTTPS proxy.

General Behavior of the Program:

Firstly note that, as this is a server program, it is meant to run indefinitely
until Ctrl+C is entered into the command line. This is how you exit the program.

Processing of an HTTP request:
When my proxy gets a "GET" request from the browser, it treats it as a normal request,
sends the request to the webserver at port 80, reads the response from the webserver and
sends it back to the browser, and finally closes the connection. (See Function proxy()).

Processing of an HTTPS request:
When my proxy gets a "CONNECT" request from the browser, the proxy first makes a connection
to the webserver at port 443 (the standard SSL port). If the connection is successful, then it
sends a "HTTP 200 OK" message to the browser. Then, the proxy uses the browser socket and webserver
socket together as a tunnel and transfers the data back and forth. In this way, the TLS handshake
needed for the HTTPS request is handled by the browser and the webserver directly.(See Function s_proxy()).

Also, note that in this program, I use the threading library, as opposed to the more popular "thread" library
from python. The reason for this is because "threading" has a convenient active_count() method that I use
to count the number of worker threads I'm using, so that I do not exceed the (possibly user-inputted)
number of workers. The downside to the "threading" library is that ctrl+C does not exit the program,
because the main thread is killed without killing the others. This is fixed by making the other threads
daemons, so that they exit once the main thread exits.

I have tested my mproxy.py program on the following sites, for which it seems to work quite well:

HTTP: http://example.com, http://theuselessweb.com
HTTPS: https://iana.org, https://google.com, https://yelp.com

(Note that the iana.org site came from clicking the "More Information" link on the http://example.com page)
At this time, this program has the following issues:
1) I am able to open multiple sites in multiple tabs at the same time only in some sessions, not all of them.
2) Making the number of workers only 10 seems to make my proxy slow (perhaps as expected).

************************************************************************************************************************

Processing of Man-in-the-Middle-style HTTP request:
This functionality is implemented in the mitmproxy.py (which is run in the same way as mproxy.py), in 2 steps:

1) Download an authentic certificate for the popular websites (google.com, yelp.com, etc.) so that the proxy can
connect to these websites. (This is cacert.pem). We then use openSSL to create our own CA and generate a server
certificate. We alter the alternate names part of the certificate to include the domain names that the certificate
should work for. The certificates generated by my CA are in servercert.pem and serverkey.pem. The file myCA.zip in my
submission includes the certificate files, openSSL configuration files, as well as the commands that I used to generate
these certificates (the commands are included in "certscript").

2) Currently, my proxy intercepts the HTTPS CONNECT request from the browser.
It then opens a socket to the webserver, wraps the socket, and reads the
required webpage from the webserver. The proxy then sends the "HTTPS 200 OK"
message to the browser and attempts to transfer the data from the webserver
to the browser. However, the browser currently is not accepting the data from the
proxy. The browser displays the following message: "Your connection is not secure". It goes on to 
give messages like,""This site uses HSTS (HTTP Strict Transport Security). As a result, it is not possible to
add an exception for this certificate", or "The certificate is not trusted because the issuer certificate is not known".
I also tried to overcome this error by getting the entire certificate chain for one of the websites (google.com) but that
also does not work. Therefore, my man-in-the-middle style proxy is able to make
a secure connection with the webserver and obtain the data, but the data it sends back to the client
is not trusted, because the browser does not trust the CA, even if it is added to its list of trusted CA's
and the CN name is identical to the webserver that the browser wants to connect to.

Logs of Requests:
I have created log directories for both the MiTM and regular proxy files (in mitmlog and log respectively).
Each log is for a single session I used with my Firefox web browser to connect to various HTTP and HTTPS websites
and contains the client response and server response. The file naming conventions are the same as those mentioned in the writeup.
Notice, also, that the Server Response parts of the files in "log/" consist of encrypted material, but the Server Response parts of
the files in "mitmlog/" do not.

